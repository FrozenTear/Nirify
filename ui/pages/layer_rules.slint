// Dynamic Layer Rules settings page
// Uses model-driven rendering for reduced compile time

import { Theme } from "../styles.slint";
import { ScrollView, LineEdit, ComboBox, Button, Slider, Switch } from "std-widgets.slint";
import { SettingsSection } from "../widgets/section.slint";
import { ColorPicker } from "../widgets/color_picker.slint";

// Universal setting model for layer rules
export struct LayerRuleSettingModel {
    id: string,              // Unique identifier for callbacks
    label: string,           // Display label
    description: string,     // Help text
    setting-type: int,       // 0=toggle, 1=slider, 2=combo, 3=text, 4=color

    // Toggle (type 0)
    bool-value: bool,

    // Slider (type 1)
    int-value: int,
    float-value: float,
    min-value: float,
    max-value: float,
    suffix: string,
    use-float: bool,         // true = float slider, false = int slider

    // ComboBox (type 2)
    combo-index: int,
    combo-options: [string],

    // Text/Color (type 3, 4)
    text-value: string,
    placeholder: string,

    // Visibility
    visible: bool,
}

// Dynamic row component - renders any setting type
component DynamicRow inherits Rectangle {
    in property <LayerRuleSettingModel> setting;

    callback toggle-changed(string, bool);
    callback slider-int-changed(string, int);
    callback slider-float-changed(string, float);
    callback combo-changed(string, int);
    callback text-changed(string, string);
    callback color-changed(string, color);

    visible: setting.visible;
    height: setting.visible ? 52px : 0;
    background: transparent;

    HorizontalLayout {
        spacing: Theme.spacing-md;
        padding: Theme.spacing-xs;
        padding-left: Theme.spacing-md;
        padding-right: Theme.spacing-md;

        // Label column
        VerticalLayout {
            horizontal-stretch: 1;
            spacing: 2px;
            alignment: center;

            Text {
                text: setting.label;
                color: Theme.text-primary;
                font-size: Theme.font-size-sm;
                font-weight: 500;
            }

            if setting.description != "": Text {
                text: setting.description;
                color: Theme.text-muted;
                font-size: Theme.font-size-xs;
                wrap: word-wrap;
            }
        }

        // Control column
        Rectangle {
            width: 200px;
            vertical-stretch: 1;

            // Toggle (type 0)
            if setting.setting-type == 0: HorizontalLayout {
                alignment: end;
                padding-right: Theme.spacing-sm;

                Switch {
                    checked: setting.bool-value;
                    toggled => {
                        root.toggle-changed(setting.id, self.checked);
                    }
                }
            }

            // Slider (type 1)
            if setting.setting-type == 1: HorizontalLayout {
                spacing: Theme.spacing-sm;
                alignment: center;

                Slider {
                    horizontal-stretch: 1;
                    minimum: setting.min-value;
                    maximum: setting.max-value;
                    value: setting.use-float ? setting.float-value : setting.int-value;
                    changed(val) => {
                        if (setting.use-float) {
                            root.slider-float-changed(setting.id, val);
                        } else {
                            root.slider-int-changed(setting.id, round(val));
                        }
                    }
                }

                Text {
                    width: 55px;
                    text: setting.use-float
                        ? round(setting.float-value * 100) + setting.suffix
                        : setting.int-value + setting.suffix;
                    color: Theme.text-secondary;
                    font-size: Theme.font-size-sm;
                    horizontal-alignment: right;
                    vertical-alignment: center;
                }
            }

            // ComboBox (type 2)
            if setting.setting-type == 2: HorizontalLayout {
                alignment: end;

                ComboBox {
                    width: 140px;
                    model: setting.combo-options;
                    current-index: setting.combo-index;
                    selected(_) => {
                        root.combo-changed(setting.id, self.current-index);
                    }
                }
            }

            // Text input (type 3)
            if setting.setting-type == 3: HorizontalLayout {
                alignment: end;

                LineEdit {
                    width: 180px;
                    text: setting.text-value;
                    placeholder-text: setting.placeholder;
                    edited(val) => {
                        root.text-changed(setting.id, val);
                    }
                }
            }

            // Color input (type 4)
            if setting.setting-type == 4: HorizontalLayout {
                alignment: end;
                spacing: Theme.spacing-xs;

                Rectangle {
                    width: 24px;
                    height: 24px;
                    border-radius: 4px;
                    background: Theme.accent;
                    border-width: 1px;
                    border-color: Theme.border;
                }

                LineEdit {
                    width: 120px;
                    text: setting.text-value;
                    placeholder-text: "#RRGGBBAA";
                    edited(val) => {
                        root.text-changed(setting.id, val);
                    }
                }
            }
        }
    }
}

// Dynamic section component
component DynamicSection inherits Rectangle {
    in property <string> title;
    in property <string> subtitle: "";
    in property <[LayerRuleSettingModel]> settings;

    callback toggle-changed(string, bool);
    callback slider-int-changed(string, int);
    callback slider-float-changed(string, float);
    callback combo-changed(string, int);
    callback text-changed(string, string);
    callback color-changed(string, color);

    background: Theme.card-background;
    border-radius: Theme.radius-md;

    VerticalLayout {
        padding: Theme.spacing-md;
        spacing: Theme.spacing-xs;

        // Section header
        Text {
            text: title;
            color: Theme.text-muted;
            font-size: Theme.font-size-xs;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        // Optional subtitle
        if subtitle != "": Text {
            text: subtitle;
            color: Theme.text-muted;
            font-size: Theme.font-size-sm;
            wrap: word-wrap;
        }

        // Dynamic rows from model
        for setting in settings: DynamicRow {
            setting: setting;
            toggle-changed(id, val) => { root.toggle-changed(id, val); }
            slider-int-changed(id, val) => { root.slider-int-changed(id, val); }
            slider-float-changed(id, val) => { root.slider-float-changed(id, val); }
            combo-changed(id, val) => { root.combo-changed(id, val); }
            text-changed(id, val) => { root.text-changed(id, val); }
            color-changed(id, val) => { root.color-changed(id, val); }
        }
    }
}

// Main page component
export component LayerRulesDynamicPage inherits Rectangle {
    accessible-role: none;
    accessible-label: "Layer rules";

    // Rule list
    in-out property <[string]> rule-list: [];
    in-out property <int> selected-rule-index: -1;

    // Match criteria list
    in-out property <[string]> matches-list: [];
    in-out property <int> selected-match-index: 0;
    in-out property <int> matches-count: 0;

    // Dynamic settings models
    in-out property <[LayerRuleSettingModel]> rule-settings: [];
    in-out property <[LayerRuleSettingModel]> match-settings: [];
    in-out property <[LayerRuleSettingModel]> visual-settings: [];
    in-out property <[LayerRuleSettingModel]> shadow-settings: [];
    in-out property <[LayerRuleSettingModel]> advanced-settings: [];

    // Rule management callbacks
    callback add-rule();
    callback remove-rule(int);
    callback select-rule(int);
    callback reorder-rule(int, int);

    // Match management callbacks
    callback add-match();
    callback remove-match(int);
    callback select-match(int);

    // Generic setting callbacks
    callback setting-toggle-changed(string, bool);
    callback setting-slider-int-changed(string, int);
    callback setting-slider-float-changed(string, float);
    callback setting-combo-changed(string, int);
    callback setting-text-changed(string, string);
    callback setting-color-changed(string, color);

    background: transparent;

    // Keyboard focus index for rules list
    property <int> focused-rule-index: -1;

    // Drag-and-drop state
    property <bool> is-dragging: false;
    property <int> drag-from-index: -1;
    property <int> drag-target-index: -1;
    property <length> drag-current-y: 0;
    property <length> item-height: 40px;

    HorizontalLayout {
        spacing: Theme.spacing-md;

        // Rules list panel
        Rectangle {
            width: Theme.panel-width-narrow;
            background: Theme.card-background;
            border-radius: Theme.radius-md;

            VerticalLayout {
                padding: Theme.spacing-sm;
                spacing: Theme.spacing-sm;

                // Header
                HorizontalLayout {
                    spacing: Theme.spacing-sm;

                    Text {
                        text: "Layer Rules";
                        color: Theme.text-primary;
                        font-size: Theme.font-size-md;
                        font-weight: 600;
                        vertical-alignment: center;
                        horizontal-stretch: 1;
                    }

                    Button {
                        text: "+";
                        accessible-label: "Add new layer rule";
                        clicked => { root.add-rule(); }
                    }
                }

                // Rules list with keyboard navigation
                rules-focus := FocusScope {
                    vertical-stretch: 1;

                    accessible-role: list;
                    accessible-label: "Layer rules list";

                    key-pressed(event) => {
                        if (event.text == Key.DownArrow) {
                            if (root.focused-rule-index < root.rule-list.length - 1) {
                                root.focused-rule-index = root.focused-rule-index + 1;
                            }
                            accept
                        } else if (event.text == Key.UpArrow) {
                            if (root.focused-rule-index > 0) {
                                root.focused-rule-index = root.focused-rule-index - 1;
                            } else if (root.focused-rule-index == -1 && root.rule-list.length > 0) {
                                root.focused-rule-index = 0;
                            }
                            accept
                        } else if (event.text == Key.Return || event.text == " ") {
                            if (root.focused-rule-index >= 0) {
                                root.selected-rule-index = root.focused-rule-index;
                                root.select-rule(root.focused-rule-index);
                            }
                            accept
                        } else if (event.text == Key.Delete) {
                            if (root.focused-rule-index >= 0 && root.focused-rule-index == root.selected-rule-index) {
                                root.remove-rule(root.focused-rule-index);
                            }
                            accept
                        }
                        reject
                    }

                    focus-changed-event => {
                        if (self.has-focus && root.focused-rule-index == -1 && root.rule-list.length > 0) {
                            root.focused-rule-index = root.selected-rule-index >= 0 ? root.selected-rule-index : 0;
                        }
                    }

                    ScrollView {
                        list-container := VerticalLayout {
                            spacing: Theme.spacing-xs;

                            for rule[index] in root.rule-list : VerticalLayout {
                                spacing: 0;

                                // Drop indicator
                                Rectangle {
                                    height: root.is-dragging && root.drag-target-index == index ? 3px : 0;
                                    background: Theme.accent;
                                    border-radius: 1.5px;
                                }

                                Rectangle {
                                    height: root.item-height;
                                    background: root.is-dragging && root.drag-from-index == index
                                        ? Theme.card-background.with-alpha(0.3)
                                        : index == root.selected-rule-index
                                            ? Theme.accent.with-alpha(0.2)
                                            : transparent;
                                    border-radius: Theme.radius-sm;
                                    border-width: index == root.focused-rule-index && rules-focus.has-focus ? 2px : 0px;
                                    border-color: Theme.accent;
                                    opacity: root.is-dragging && root.drag-from-index == index ? 0.5 : 1.0;

                                    accessible-role: list-item;
                                    accessible-label: rule;

                                    touch := TouchArea {
                                        property <length> press-start-y: 0;
                                        property <bool> drag-started: false;

                                        pointer-event(event) => {
                                            if (event.kind == PointerEventKind.down && event.button == PointerEventButton.left) {
                                                self.press-start-y = self.mouse-y;
                                                self.drag-started = false;
                                            } else if (event.kind == PointerEventKind.up || event.kind == PointerEventKind.cancel) {
                                                if (root.is-dragging) {
                                                    if (root.drag-target-index >= 0 && root.drag-target-index != root.drag-from-index) {
                                                        root.reorder-rule(root.drag-from-index, root.drag-target-index);
                                                    }
                                                    root.is-dragging = false;
                                                    root.drag-from-index = -1;
                                                    root.drag-target-index = -1;
                                                } else if (!self.drag-started) {
                                                    root.focused-rule-index = index;
                                                    root.selected-rule-index = index;
                                                    root.select-rule(index);
                                                    rules-focus.focus();
                                                }
                                                self.drag-started = false;
                                            }
                                        }

                                        moved => {
                                            if (self.pressed) {
                                                if (!self.drag-started && abs(self.mouse-y - self.press-start-y) > 5px) {
                                                    self.drag-started = true;
                                                    root.is-dragging = true;
                                                    root.drag-from-index = index;
                                                }

                                                if (root.is-dragging) {
                                                    root.drag-current-y = self.mouse-y + index * (root.item-height + Theme.spacing-xs);
                                                    root.drag-target-index = clamp(
                                                        round(root.drag-current-y / (root.item-height + Theme.spacing-xs)),
                                                        0,
                                                        root.rule-list.length
                                                    );
                                                }
                                            }
                                        }
                                    }

                                    HorizontalLayout {
                                        padding-left: Theme.spacing-sm;
                                        padding-right: Theme.spacing-sm;

                                        Text {
                                            text: rule;
                                            color: index == root.selected-rule-index ? Theme.accent : Theme.text-primary;
                                            font-size: Theme.font-size-sm;
                                            vertical-alignment: center;
                                            horizontal-stretch: 1;
                                            overflow: elide;
                                        }

                                        Button {
                                            visible: index == root.selected-rule-index && !root.is-dragging;
                                            text: "Ã—";
                                            accessible-label: "Remove rule";
                                            clicked => { root.remove-rule(index); }
                                        }
                                    }
                                }
                            }

                            // Drop indicator at end
                            Rectangle {
                                height: root.is-dragging && root.drag-target-index == root.rule-list.length ? 3px : 0;
                                background: Theme.accent;
                                border-radius: 1.5px;
                            }

                            if root.rule-list.length == 0: Text {
                                text: "No layer rules yet.\nClick + to add one.";
                                color: Theme.text-muted;
                                font-size: Theme.font-size-sm;
                                horizontal-alignment: center;
                            }
                        }

                        // Ghost item while dragging
                        if root.is-dragging && root.drag-from-index >= 0 && root.drag-from-index < root.rule-list.length: Rectangle {
                            x: Theme.spacing-sm;
                            y: root.drag-current-y - root.item-height / 2;
                            width: list-container.width - Theme.spacing-md;
                            height: root.item-height;
                            background: Theme.card-background;
                            border-radius: Theme.radius-sm;
                            border-width: 2px;
                            border-color: Theme.accent;
                            opacity: 0.9;

                            HorizontalLayout {
                                padding-left: Theme.spacing-sm;
                                padding-right: Theme.spacing-sm;

                                Text {
                                    text: root.rule-list[root.drag-from-index];
                                    color: Theme.accent;
                                    font-size: Theme.font-size-sm;
                                    vertical-alignment: center;
                                    overflow: elide;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Rule editor panel
        if root.selected-rule-index >= 0: Rectangle {
            horizontal-stretch: 1;

            ScrollView {
                VerticalLayout {
                    alignment: start;
                    spacing: Theme.spacing-lg;
                    padding-right: Theme.spacing-md;

                    // Rule Settings Section
                    DynamicSection {
                        title: "RULE SETTINGS";
                        settings: root.rule-settings;
                        toggle-changed(id, val) => { root.setting-toggle-changed(id, val); }
                        slider-int-changed(id, val) => { root.setting-slider-int-changed(id, val); }
                        slider-float-changed(id, val) => { root.setting-slider-float-changed(id, val); }
                        combo-changed(id, val) => { root.setting-combo-changed(id, val); }
                        text-changed(id, val) => { root.setting-text-changed(id, val); }
                        color-changed(id, val) => { root.setting-color-changed(id, val); }
                    }

                    // Match Criteria Section
                    Rectangle {
                        background: Theme.card-background;
                        border-radius: Theme.radius-md;

                        VerticalLayout {
                            padding: Theme.spacing-md;
                            spacing: Theme.spacing-sm;

                            Text {
                                text: "MATCH CRITERIA";
                                color: Theme.text-muted;
                                font-size: Theme.font-size-xs;
                                font-weight: 600;
                                letter-spacing: 0.5px;
                            }

                            Text {
                                text: "Rule applies if ANY match criteria is satisfied";
                                color: Theme.text-muted;
                                font-size: Theme.font-size-sm;
                                wrap: word-wrap;
                            }

                            // Match list controls
                            HorizontalLayout {
                                spacing: Theme.spacing-sm;
                                height: 28px;

                                Text {
                                    text: "Match entries:";
                                    color: Theme.text-secondary;
                                    font-size: Theme.font-size-sm;
                                    vertical-alignment: center;
                                }

                                Rectangle { horizontal-stretch: 1; }

                                Button {
                                    text: "+";
                                    accessible-label: "Add match criteria";
                                    clicked => { root.add-match(); }
                                }

                                if root.matches-count > 1: Button {
                                    text: "-";
                                    accessible-label: "Remove selected match criteria";
                                    clicked => { root.remove-match(root.selected-match-index); }
                                }
                            }

                            // Match selector chips
                            if root.matches-count > 0: HorizontalLayout {
                                spacing: Theme.spacing-xs;

                                for match-label[idx] in root.matches-list : Rectangle {
                                    height: 28px;
                                    min-width: 60px;
                                    background: idx == root.selected-match-index ? Theme.accent : Theme.background;
                                    border-radius: Theme.radius-sm;
                                    border-width: 1px;
                                    border-color: idx == root.selected-match-index ? Theme.accent : Theme.border;

                                    TouchArea {
                                        accessible-role: button;
                                        accessible-label: "Select match criteria " + (idx + 1);

                                        clicked => {
                                            root.selected-match-index = idx;
                                            root.select-match(idx);
                                        }
                                    }

                                    HorizontalLayout {
                                        padding-left: Theme.spacing-sm;
                                        padding-right: Theme.spacing-sm;
                                        alignment: center;

                                        Text {
                                            text: "Match " + (idx + 1);
                                            color: idx == root.selected-match-index ? #ffffff : Theme.text-primary;
                                            font-size: Theme.font-size-sm;
                                            vertical-alignment: center;
                                        }
                                    }
                                }
                            }

                            // Dynamic match settings
                            for setting in root.match-settings: DynamicRow {
                                setting: setting;
                                toggle-changed(id, val) => { root.setting-toggle-changed(id, val); }
                                slider-int-changed(id, val) => { root.setting-slider-int-changed(id, val); }
                                slider-float-changed(id, val) => { root.setting-slider-float-changed(id, val); }
                                combo-changed(id, val) => { root.setting-combo-changed(id, val); }
                                text-changed(id, val) => { root.setting-text-changed(id, val); }
                                color-changed(id, val) => { root.setting-color-changed(id, val); }
                            }
                        }
                    }

                    // Visual Properties Section
                    DynamicSection {
                        title: "VISUAL PROPERTIES";
                        settings: root.visual-settings;
                        toggle-changed(id, val) => { root.setting-toggle-changed(id, val); }
                        slider-int-changed(id, val) => { root.setting-slider-int-changed(id, val); }
                        slider-float-changed(id, val) => { root.setting-slider-float-changed(id, val); }
                        combo-changed(id, val) => { root.setting-combo-changed(id, val); }
                        text-changed(id, val) => { root.setting-text-changed(id, val); }
                        color-changed(id, val) => { root.setting-color-changed(id, val); }
                    }

                    // Shadow Section
                    DynamicSection {
                        title: "SHADOW";
                        settings: root.shadow-settings;
                        toggle-changed(id, val) => { root.setting-toggle-changed(id, val); }
                        slider-int-changed(id, val) => { root.setting-slider-int-changed(id, val); }
                        slider-float-changed(id, val) => { root.setting-slider-float-changed(id, val); }
                        combo-changed(id, val) => { root.setting-combo-changed(id, val); }
                        text-changed(id, val) => { root.setting-text-changed(id, val); }
                        color-changed(id, val) => { root.setting-color-changed(id, val); }
                    }

                    // Advanced Section
                    DynamicSection {
                        title: "ADVANCED";
                        settings: root.advanced-settings;
                        toggle-changed(id, val) => { root.setting-toggle-changed(id, val); }
                        slider-int-changed(id, val) => { root.setting-slider-int-changed(id, val); }
                        slider-float-changed(id, val) => { root.setting-slider-float-changed(id, val); }
                        combo-changed(id, val) => { root.setting-combo-changed(id, val); }
                        text-changed(id, val) => { root.setting-text-changed(id, val); }
                        color-changed(id, val) => { root.setting-color-changed(id, val); }
                    }

                    // Spacer at bottom
                    Rectangle { height: Theme.spacing-lg; }
                }
            }
        }

        // No selection message
        if root.selected-rule-index < 0: Rectangle {
            horizontal-stretch: 1;
            background: Theme.card-background;
            border-radius: Theme.radius-md;

            VerticalLayout {
                alignment: center;

                Text {
                    text: "Select a rule to edit";
                    color: Theme.text-muted;
                    font-size: Theme.font-size-md;
                    horizontal-alignment: center;
                }

                Text {
                    text: "Or click + to create a new rule";
                    color: Theme.text-muted;
                    font-size: Theme.font-size-sm;
                    horizontal-alignment: center;
                }

                Rectangle { height: Theme.spacing-md; }

                Text {
                    text: "Layer rules apply to layer-shell surfaces\nlike panels, notifications, and widgets.";
                    color: Theme.text-muted;
                    font-size: Theme.font-size-sm;
                    horizontal-alignment: center;
                }
            }
        }
    }
}
